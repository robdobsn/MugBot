import { useState } from 'react'
import { type MugParameters } from '../App'

interface GCodeGeneratorProps {
  svgPaths: any[]
  parameters: MugParameters
}

function GCodeGenerator({ svgPaths, parameters }: GCodeGeneratorProps) {
  const [gcode, setGcode] = useState<string>('')
  const [isGenerating, setIsGenerating] = useState(false)
  const [isSending, setIsSending] = useState(false)
  const [status, setStatus] = useState<string>('')

  const generateGCode = () => {
    console.log('generateGCode called, paths:', svgPaths.length)
    
    if (svgPaths.length === 0) {
      setStatus('Please load an SVG file first')
      return
    }

    setIsGenerating(true)
    setStatus('Generating GCODE...')

    try {
      const lines: string[] = []
      
      // GCODE header
      lines.push('; MugBot GCODE - Generated by MugBot UI')
      lines.push('; Date: ' + new Date().toISOString())
      lines.push('; X Range: ' + parameters.xRange + 'mm')
      lines.push('; Y Range: ' + parameters.yRange + 'mm')
      lines.push('; Extrusion Rate: ' + parameters.extrusionRate)
      lines.push('; Z Position: 0mm (fixed)')
      lines.push('')
      lines.push('G21 ; Set units to millimeters')
      lines.push('G90 ; Absolute positioning')
      lines.push('M83 ; Relative extrusion mode')
      lines.push('G92 E0 ; Reset extruder position')
      lines.push('')
      lines.push('; Move to start position')
      lines.push('G0 Z0 F3000 ; Set Z to 0')
      lines.push('G0 X0 Y0 F3000 ; Move to origin')
      lines.push('')

      // Process each SVG path
      svgPaths.forEach((pathData, pathIndex) => {
        lines.push('; Path ' + (pathIndex + 1))
        
        const pathPoints = parseSvgPathToGCode(pathData.d, parameters)
        
        if (pathPoints.length > 0) {
          // Move to start without extrusion
          lines.push('G0 X' + pathPoints[0].x.toFixed(3) + ' Y' + pathPoints[0].y.toFixed(3) + ' F3000')
          
          // Draw the path
          for (let i = 1; i < pathPoints.length; i++) {
            const point = pathPoints[i]
            const prevPoint = pathPoints[i - 1]
            
            // Calculate distance for extrusion
            const dx = point.x - prevPoint.x
            const dy = point.y - prevPoint.y
            const distance = Math.sqrt(dx * dx + dy * dy)
            const extrusion = distance * parameters.extrusionRate * 0.1
            
            lines.push('G1 X' + point.x.toFixed(3) + ' Y' + point.y.toFixed(3) + ' E' + extrusion.toFixed(5) + ' F1500')
          }
        }
        
        lines.push('')
      })

      // GCODE footer
      lines.push('; End of print')
      lines.push('G0 Z5 F1000 ; Lift nozzle')
      lines.push('G0 X0 Y0 F3000 ; Return to origin')
      lines.push('M400 ; Wait for moves to finish')
      lines.push('M84 ; Disable motors')

      const gcodeContent = lines.join('\n')
      setGcode(gcodeContent)
      setStatus('GCODE generated successfully (' + lines.length + ' lines)')
    } catch (error) {
      setStatus('Error generating GCODE: ' + (error as Error).message)
    } finally {
      setIsGenerating(false)
    }
  }

  const parseSvgPathToGCode = (pathD: string, params: MugParameters): Array<{x: number, y: number}> => {
    const points: Array<{x: number, y: number}> = []
    const commands = pathD.match(/[MmLlHhVvCcSsQqTtAaZz][^MmLlHhVvCcSsQqTtAaZz]*/g) || []
    
    let currentX = 0
    let currentY = 0
    let startX = 0
    let startY = 0

    // Find SVG bounds
    let minX = Infinity, maxX = -Infinity
    let minY = Infinity, maxY = -Infinity
    
    commands.forEach(cmd => {
      const coords = cmd.slice(1).trim().split(/[\s,]+/).map(parseFloat).filter(n => !isNaN(n))
      
      for (let i = 0; i < coords.length; i += 2) {
        if (coords[i] !== undefined) {
          minX = Math.min(minX, coords[i])
          maxX = Math.max(maxX, coords[i])
        }
        if (coords[i + 1] !== undefined) {
          minY = Math.min(minY, coords[i + 1])
          maxY = Math.max(maxY, coords[i + 1])
        }
      }
    })

    const svgWidth = maxX - minX || 1
    const svgHeight = maxY - minY || 1

    // Convert path commands to points
    commands.forEach(cmd => {
      const type = cmd[0]
      const coords = cmd.slice(1).trim().split(/[\s,]+/).map(parseFloat).filter(n => !isNaN(n))

      switch (type.toUpperCase()) {
        case 'M':
          if (coords.length >= 2) {
            currentX = type === 'M' ? coords[0] : currentX + coords[0]
            currentY = type === 'M' ? coords[1] : currentY + coords[1]
            startX = currentX
            startY = currentY
            points.push(convertToMugCoords(currentX, currentY, minX, minY, svgWidth, svgHeight, params))
          }
          break

        case 'L':
          for (let i = 0; i < coords.length; i += 2) {
            if (coords[i] !== undefined && coords[i + 1] !== undefined) {
              const newX = type === 'L' ? coords[i] : currentX + coords[i]
              const newY = type === 'L' ? coords[i + 1] : currentY + coords[i + 1]
              
              // Add intermediate points for smooth curves
              const steps = 5
              for (let step = 1; step <= steps; step++) {
                const t = step / steps
                const x = currentX + (newX - currentX) * t
                const y = currentY + (newY - currentY) * t
                points.push(convertToMugCoords(x, y, minX, minY, svgWidth, svgHeight, params))
              }
              
              currentX = newX
              currentY = newY
            }
          }
          break

        case 'H':
          for (let i = 0; i < coords.length; i++) {
            if (coords[i] !== undefined) {
              const newX = type === 'H' ? coords[i] : currentX + coords[i]
              const steps = 5
              for (let step = 1; step <= steps; step++) {
                const t = step / steps
                const x = currentX + (newX - currentX) * t
                points.push(convertToMugCoords(x, currentY, minX, minY, svgWidth, svgHeight, params))
              }
              currentX = newX
            }
          }
          break

        case 'V':
          for (let i = 0; i < coords.length; i++) {
            if (coords[i] !== undefined) {
              const newY = type === 'V' ? coords[i] : currentY + coords[i]
              const steps = 5
              for (let step = 1; step <= steps; step++) {
                const t = step / steps
                const y = currentY + (newY - currentY) * t
                points.push(convertToMugCoords(currentX, y, minX, minY, svgWidth, svgHeight, params))
              }
              currentY = newY
            }
          }
          break

        case 'Z':
          if (startX !== currentX || startY !== currentY) {
            const steps = 5
            for (let step = 1; step <= steps; step++) {
              const t = step / steps
              const x = currentX + (startX - currentX) * t
              const y = currentY + (startY - currentY) * t
              points.push(convertToMugCoords(x, y, minX, minY, svgWidth, svgHeight, params))
            }
          }
          currentX = startX
          currentY = startY
          break
      }
    })

    return points
  }

  const convertToMugCoords = (
    svgX: number,
    svgY: number,
    minX: number,
    minY: number,
    svgWidth: number,
    svgHeight: number,
    params: MugParameters
  ): {x: number, y: number} => {
    // Normalize SVG coordinates (0 to 1)
    const normalizedX = (svgX - minX) / svgWidth
    const normalizedY = (svgY - minY) / svgHeight

    // Map to mug dimensions
    // X is rotation around mug (0 to xRange)
    const x = normalizedX * params.xRange
    // Y is vertical height (0 to yRange)
    const y = normalizedY * params.yRange

    return { x, y }
  }

  const downloadGCode = () => {
    if (!gcode) return

    const blob = new Blob([gcode], { type: 'text/plain' })
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = 'mugbot_' + new Date().getTime() + '.gcode'
    document.body.appendChild(a)
    a.click()
    document.body.removeChild(a)
    URL.revokeObjectURL(url)
    
    setStatus('GCODE file downloaded')
  }

  const sendToDuet = async () => {
    if (!gcode) {
      setStatus('Generate GCODE first')
      return
    }

    if (!parameters.duetIp) {
      setStatus('Please enter Duet IP address')
      return
    }

    setIsSending(true)
    setStatus('Uploading to Duet 2...')

    try {
      // Create form data
      const formData = new FormData()
      const blob = new Blob([gcode], { type: 'text/plain' })
      const filename = 'mugbot_' + new Date().getTime() + '.gcode'
      formData.append('file', blob, filename)

      // Upload to Duet 2 using RRF3 API
      const uploadUrl = `http://${parameters.duetIp}/rr_upload?name=0:/gcodes/${filename}`
      
      await fetch(uploadUrl, {
        method: 'POST',
        body: formData,
        mode: 'no-cors' // Note: This may require CORS configuration on Duet
      })

      // Since we're using no-cors, we can't read the response
      // Assume success if no error was thrown
      setStatus('GCODE uploaded successfully to Duet 2')
      
      // Optionally, you could also start the print job:
      // await fetch(`http://${parameters.duetIp}/rr_gcode?gcode=M32 "${filename}"`, { mode: 'no-cors' })
      
    } catch (error) {
      setStatus('Error uploading to Duet: ' + (error as Error).message)
      console.error('Upload error:', error)
    } finally {
      setIsSending(false)
    }
  }

  return (
    <div>
      <div className="d-grid gap-2 mb-3">
        <button 
          className="btn btn-primary"
          onClick={generateGCode}
          disabled={isGenerating || svgPaths.length === 0}
        >
          {isGenerating ? 'Generating...' : 'Generate GCODE'}
        </button>

        <button 
          className="btn btn-success"
          onClick={downloadGCode}
          disabled={!gcode}
        >
          Download GCODE
        </button>

        <button 
          className="btn btn-warning"
          onClick={sendToDuet}
          disabled={!gcode || isSending}
        >
          {isSending ? 'Uploading...' : 'Send to Duet 2'}
        </button>
      </div>

      {status && (
        <div className={`alert ${status.includes('Error') ? 'alert-danger' : 'alert-info'} small mb-3`}>
          {status}
        </div>
      )}

      {gcode && (
        <div>
          <label className="form-label small fw-bold">GCODE Preview:</label>
          <textarea 
            className="form-control font-monospace small"
            rows={10}
            value={gcode}
            readOnly
            style={{ fontSize: '0.75rem' }}
          />
          <small className="text-muted d-block mt-1">
            {gcode.split('\n').length} lines, {(gcode.length / 1024).toFixed(1)} KB
          </small>
        </div>
      )}
    </div>
  )
}

export default GCodeGenerator
